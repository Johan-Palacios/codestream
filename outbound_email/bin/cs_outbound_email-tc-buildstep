#!/usr/bin/env python3

#desc# Standard interface to CodeStream's TeamCity build process

import os
import sys

sys.path.append(os.environ['DT_TOP'] + "/lib")
import devTools
import awsLambda
from sysUtils import dumpDict, shellExecNoBuffer, someValueOrNone, readJsonFileIgnoreComments
from buildUtils import *

assetExtensionList = ['info', 'zip', 'lambda.json']

args = parseStandardBuildArgs()
dt = devTools.devTools()
awsL = awsLambda.awsLambda()
buildData = buildInit(__file__, dt, args)
buildDir = buildData['sandboxTop'] + "/src"
os.chdir(buildDir)
if args.verbose: print("current directory is", buildDir)

if args.action == 'prep':
	buildstepPrep(args)
	exit(0)

if args.action == 'clean' or args.action == 'destroy':
	buildstepGeneric(args, cmd = "npm run clean", workingDir = buildDir)

if args.action == 'destroy':
	buildstepDestroy(args, buildData)

if args.action == 'build':
	pkgInfo = getPackageInfo(buildData = buildData, gitRepoCommitDir = buildData['sandboxTop'])
	buildstepGeneric(args, cmd = "npm run build", workingDir = buildDir)
	buildstepGeneric(args, cmd = "npm run lambda:config", workingDir = buildDir)
	os.rename("../out/outbound-email.zip", "../out/" + pkgInfo['localAssetFilePrefix'] + ".zip")
	os.rename("../out/outbound-email.lambda.json", "../out/" + pkgInfo['localAssetFilePrefix'] + ".lambda.json")
	md5zip = dt.md5Hash("../out/" + pkgInfo['localAssetFilePrefix'] + ".zip")
	md5json = dt.md5Hash("../out/" + pkgInfo['localAssetFilePrefix'] + ".lambda.json")
	pkgInfo['assetsMD5'][pkgInfo['localAssetFilePrefix'] + ".zip"] = md5zip
	pkgInfo['assetsMD5'][pkgInfo['localAssetFilePrefix'] + ".lambda.json"] = md5json
	dumpDict(pkgInfo, "../out/" + pkgInfo['localAssetFilePrefix'] + ".info")
	if args.verbose: dumpDict(pkgInfo, None, "Package Info:")
	shellExecNoBuffer("ls -l " + pkgInfo['localAssetFilePrefix'] + ".*", workingDir = "../out", printCmd = True)

if args.action == 'citest':
	buildstepGeneric(args, cmd = "echo Testing not configured", workingDir = buildDir)

if args.action == 'promote':
	# fetch assets from args.build_env build (usually ci) and modify them for this build environment
	sourceAssetEnv = None
	if args.build_env:
		sourceAssetEnv = args.build_env
	elif buildData['assetEnv'] == 'prod':
		sourceAssetEnv = 'qa'
	elif buildData['assetEnv'] == 'pd':
		sourceAssetEnv = 'ci'
	elif buildData['sbInfo']['cfg_file'] == 'dev-build.sh':
		sourceAssetEnv = 'ci'
	else:
		print("you must specify --build-env")
		exit(1)
	print("sourceAssetEnv =", sourceAssetEnv)
	fetchArtifacts(args, buildData, assetExtensionList, destDir = "../out/" + sourceAssetEnv, sourceAssetEnv = sourceAssetEnv, publishDir = "outbound-email")
	buildstepGeneric(args, cmd = "npm run lambda:config", workingDir = buildDir)
	os.rename("../out/outbound-email.lambda.json", "../out/" + buildData['givenBuildNumber'] + ".lambda.json")
	os.rename("../out/" + sourceAssetEnv + "/" + buildData['givenBuildNumber'] + ".zip", "../out/" + buildData['givenBuildNumber'] + ".zip")
	pkgInfo = readJsonFileIgnoreComments("../out/" + sourceAssetEnv + "/" + buildData['givenBuildNumber'] + ".info")
	pkgInfo['assetEnvironment'] = os.environ['CS_OUTBOUND_EMAIL_ASSET_ENV']
	dumpDict(pkgInfo, "../out/" + buildData['givenBuildNumber'] + ".info")
	if args.verbose: dumpDict(pkgInfo, None, "New package info:")
	buildstepGeneric(args, cmd = "/bin/rm -rf " + "../out/" + sourceAssetEnv, workingDir = buildDir)

if args.action == 'update':
	# install the artifiacts (update the lambda code and environment)
	os.rename("../out/" + buildData['givenBuildNumber'] + ".zip", "../out/outbound-email.zip")
	os.rename("../out/" + buildData['givenBuildNumber'] + ".lambda.json", "../out/outbound-email.lambda.json")
	if awsL.lambdaFunctionExists(os.environ['CS_OUTBOUND_EMAIL_SQS']):
		print("updating lambda function code an environment")
		buildstepGeneric(args, cmd = "npm run lambda:update_env", workingDir = buildDir)
		buildstepGeneric(args, cmd = "npm run lambda:update_code", workingDir = buildDir)
	else:
		print("lambda function does not exist, installing it along with the trigger")
		buildstepGeneric(args, cmd = "npm run lambda:install_func", workingDir = buildDir)
		buildstepGeneric(args, cmd = "npm run lambda:install_trigger", workingDir = buildDir)
	os.rename("../out/outbound-email.zip", "../out/" + buildData['givenBuildNumber'] + ".zip")
	os.rename("../out/outbound-email.lambda.json", "../out/" + buildData['givenBuildNumber'] + ".lambda.json")
	os.unlink("../out/outbound-email.lambda-environment.json")

if args.action == 'publish':
	publishArtifacts(args, buildData, assetExtensionList, sourceDir = "../out", publishDir = "outbound-email")

if args.action == 'release':
	if os.environ['CS_OUTBOUND_EMAIL_ASSET_ENV'] != "prod":
		print("release can only be run in a sandbox configured for production")
		exit(1)
	infoFileName = "../out/" + args.build_number + ".info"
	pkgInfo = readJsonFileIgnoreComments(infoFileName)
	applyTagToRepos(os.environ['CS_OUTBOUND_EMAIL_SANDBOX'], "v" + pkgInfo['version'], pkgInfo['repoCommitId'])
	updatePackageVersion(buildData['sandboxTop'] + "/src/package.json", "develop", pkgInfo['version'], bumpLevel = 'patch')
